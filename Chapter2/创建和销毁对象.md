## 创建和销毁对象🍔

​    这一章讨论创建和销毁对象：什么时候和如何创建对象，什么时候避免创建他们，如果确定这些对象及时被销毁，以及如果管理对象销毁之前的清理工作。

### 样例1: 用静态工厂的方法代替构造函数

​    对于一个类来说，让一个客户端获取一个实例的传统方式是提供一个公共的构造函数。还有另外一个技巧是应该所有编程者应该具备的，那就是可以让一个类提供一个简单的静态方法用来返回这个类的实例，可以称为***公共静态工厂方法***。下面有一个简单的例子，Boolean（boolean的装箱类）。这个方法将一个原始的boolean值转化为了Boolean对象引用：

```java
public static Boolean valueOf(boolean b){
  	return b? Boolean.TRUE : Boolean.FALSE;
}
```

​    要说明的是，一个静态工厂方法不等于***设计模式中的工厂模式***。在这个样例中描述的静态工厂方法与设计模式中的有所不同。

  一个类在提供它的客户端时都带有静态工厂方法或者公共的构造函数。而用静态工厂方法替代公共构造函数时有优点也有缺点。

  **静态工厂方法的优点是有自己的名字，这一点与构造函数不同**。如果从参数到任何一个构造函数没有描述该对象有返回值，则带有名字的静态工厂方法更容易使用，同时代码可读性更强。例如，构造函数`BigInteger(int, int, Random)`  返回了一个质数，如果它能有一个更好的静态工厂方法的表达方式叫做`BigInteger.probalePrime`(这个方法已经被加到Java 4中了)。

​    每个类只能有唯一一个带有标识的构造函数。编程者已经知道通过利用参数列表中参数类型的顺序区分不同的构造函数。这是一个不好的方法。使用这种API的用户永远不会记得哪个构造函数是哪个，最终会以不小心调用错的函数而告终。当人们阅读代码时，如果没有接口文档的参考，他们是不会知道用这些构造函数做了些什么事情。

  而有名字的静态工厂方法不会出现前文所提到的问题，在某些案例中，当一个类需要多个有着相同标识的构造器时，用自定义方法名的静态工厂方法去替换这些构造器，区分它们的不同。

​    **第二个静态工厂方法的优点是，它们每次被调用时，不必每次创建一个新的对象，这与构造函数不同。** 这能让不可变类（样例17）（*译者注🍗：例如String*）使用预先构造的实例，或者当这些实例被构造时，缓存下来，重复的分发这些实例，避免创建不必要的重复对象。`Boolean.valueOf(boolean)`方法就体现了这个技巧：它从来不创建新的对象。这个技巧与***轻量级模式***（*译者注🍗：轻量级模式主要用于减少对象的创建个数或者去降低内存使用，提高性能，来自Google*）相似。在相同对象被频繁的请求下大幅度的提升性能，尤其是在需要消耗大量资源去创建对象时。

​    静态工厂方法可以让类在多个实例情况下时，从重复的函数调用中返回相同的对象。这样的类称为***实例控制（Instance-controlled）*** 。写实例控制类的理由有很多。实例控制类可以保证一个类是单例的（样例3）和不可实例化的（样例4）。另外，它同样允许不可变类（样例17）保证了没有两个相同的实例的存在：`a.equals(b)`当且仅当a==b。这是轻量级模式的基础【Gamma95】。枚举类型也可以提供这样的保障。

​    **第三个静态工厂方法与构造函数不同的优点是，它们可以返回一个对象的任何子类型作为它们的返回类型。** 这在选择返回类的对象时提供了很大的灵活空间。

  一个灵活的应用就是一个API可以返回一个非公共的类的对象。通过隐藏实现的方式可以压缩API。这种技术适用于接口框架（样例20），接口可以为静态工厂方法提供自然的返回类型。

​    在Java8之前，接口是不可以有静态方法的。正常情况下，一个接口的静态工厂方法被称为***Type*** *（译者注🍗：我没想好这里该怎么翻译）*，Type被放到一个非实例化的同伴类中（样例4）叫做***Types*** 。例如，Java的集合框架中有45种对于它接口的实现，提供了不可改变的集合，同步的集合 等等。几乎所有的方法都是通过静态工厂方法在一个非实例类中（`java.util.Collections`）对外提供服务的。这些类的返回的对象都是非公共的。

​    集合框架的API比它原来45个独立的公共类要小的多，对每一个都方便的实现了。它减少的不仅是API还有概念的部分：程序员为了使用API所必须要掌握的概念的难度和个数。*（译者注🍗：说白了就是不用记住那么多繁琐的API）*。程序员知道这些返回的对象可以通过接口准确的API获取，说一不需要读附加的实现这个类的文档。还有就是，使用这样的静态工厂方法需要客户端参考接口返回的对象，而不是它的实现类，这是一个非常好的办法（样例64）。

​    在Java8中，接口不能包含静态方法的限制已经被移除，所以这就可以为接口提供一个非实例化的同伴类。原本有许多被放置在自己方法里的公开静态成员变量，现在应该将他们放进自己的接口里。要注意的是，还是有必要将具体的实现代码放在这些静态方法的后面在独立的私有类包中。这是因为Java8需要所有的在接口中的静态成员变量是公共的。Java9中允许有私有的静态方法，但是静态属性和静态成员类还是需要被公开。

​    第五个静态工厂的优点是，返回对象在类包含的方法被重写时不需要存在。如此灵活的静态工厂方法形成了***服务提供者框架（service provider framework）***的基础。就像Java数据库链接API（JDBC）一样。服务提供框架是在一个系统中提供者去实现一个服务，系统让这些实现暴露给客户端，为从客户端到具体实现解了耦合。

​	在服务提供者框架中有**三个**重要的组件，**服务接口**，实现具体内容；**注册API的提供者**，提供了注册到实现的使用；另一个就是**服务获取API**，客户端可以用它来获取服务的实例。服务获取API可以为客户端细化标准来选择对应的实现。如果这样的标准缺失，这个API就会返回一个默认实现的实例。服务获取API就是灵活的静态工厂方法，也就是服务提供者框架的基础。

​	**第四个**可以作为服务提供者框架的组件是**服务提供者的接口**，它描述了一个工厂对象创建了服务接口的实例。如果缺失了这个服务提供者的接口，这些实现就会通过反射来实例化（样例65）。在JDBC的实例中，`Connection`就是服务接口的一部分，`DriverManager.registerDriver`是注册API提供者，`DriverManager.getConnection`是服务获取API，`Driver`就是服务接口的提供者。

​	有很多种类的服务提供者框架模式，例如，服务获取API可以提供为客户端提供比起自己编写装饰出来的接口更加丰富的接口服务。这就是***桥接设计模式（Bridge pattern）【Gamma95】*** 。依赖注入框架（样例5）是一个非常有影响力的服务提供者。自从Java6开始，平台就开始包含了一些一般目的的服务提供者框架，比如`java.util.ServiceLoader`，所以你不需要，通常情况下，你自己也不需要实现这个过程。JDBC没有使用ServiceLoader，是因为前者比后者更早出现。

​	提供唯一的静态工厂方法的主要限制是，类如果没有公共的或者受保护的构造方法时是不能被子类化的。例如，在集合框架中，不可能子类化任何的便捷实现类*（译者注😂：应该是上文说的静态工厂方法所在类）*。因祸得福，因为它鼓励程序员使用组合代替继承（样例18），并且对于不可变类型是必需的（样例17）*（译者注😂：我懵逼了，这是说啥呢，🈶️知道的小伙伴来更一下）*

​	第二个静态工厂方法的不足是，对于程序员来说很难找到。它们不像构造方法一样在API文档中有体现，所以比起通过构造方法，静态工厂方法实例化一个类是比较困难的。Javadoc工具也许某一天会对静态工厂方法加以关注。同时，你可以通过关注一个类中的静态工厂或者接口文档，或者通过遵守公共命名的约定减少这个问题的发生。这里有一些静态工厂方法的公共命名，下面这些只是其中一部分，不全🙈：

* **from** 一个类型转化方法，输入一个参数，返回相同类型的实例，例如：

  `Date d = Date.from(instant);`

* **of**一个合计的方法可以输入多个参数，返回一个这个类型的实例合并它们。

  `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);`

* **valueOf** 一个对于**from** 和**of**有些冗余的方法，例如：

  `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`

* **instance**或者**getInstance** 返回一个实例，该实例由它的参数(如果有的话)决定，但不能说具有相同的值，例如：

  `StackWalker luke = StackWalker.getInstance(options);`

* **create** 或者 **newInstance** 类似**instance**或者**getInstance** ，不同的是每个方法保证了返回一个新的实例，例如：

  `Object newArray = Array.newInstance(classObject, arrayLen);`

* **get** ***Type*** 像**getInstance**，在工厂方法在不同的类中所使用的，***Type***是工厂方法返回对象的类型，例如：

  `FileStore fs = Files.getFileStore(path);`

* **new** ***Type*** 像**newInstance**，在工厂方法在不同的类中所使用的，***Type***是工厂方法返回对象的类型，例如：

  `BufferedReader br = Files.newBufferedReader(path);`

* **type** 一个对于getType和newType的简要的方法，例如：

  `List<Complaint> litany = Collections.list(legacyLitany);`

总的来说，静态工厂方法和公共构造方法都有它们各自的用途，了解它们各自的好处是值得的，静态工厂更受人青睐，所以，尽量避免提供公共的构造方法，而第一优先考虑使用静态工厂。



***（译者注😂：终于翻译完了。。这一个item5页pdf。。欢迎大家一切翻译讨论这本Effective Java，如果你喜欢请帮我点Star✨，我会持续更新。。谢谢）***

